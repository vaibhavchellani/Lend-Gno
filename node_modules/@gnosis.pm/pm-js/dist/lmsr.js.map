{"version":3,"sources":["../src/lmsr.js"],"names":["calcLMSRCost","calcLMSRProfit","calcLMSROutcomeTokenCount","calcLMSRMarginalPrice","arguments","methodName","functionInputs","name","type","defaults","feeFactor","netOutcomeTokensSold","funding","outcomeTokenIndex","outcomeTokenCount","Decimal","toString","baseCost","b","dividedBy","length","ln","times","reduce","acc","numShares","i","plus","exp","minus","ceil","floor","cost","every","quantity","div","valueOf","expOffset","max","sub","tokensSold","add"],"mappings":"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","file":"lmsr.js","sourcesContent":["import { Decimal, normalizeWeb3Args } from './utils'\n\n/**\n * Estimates the cost of buying specified number of outcome tokens from LMSR market. Unfunded markets will be handled as a special case, returning the outcomeTokenCount passed plus its corresponding fee fee.\n * @param {number[]|string[]|BigNumber[]} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold. Negative amount means more have been bought than sold.\n * @param {number|string|BigNumber} opts.funding - The amount of funding market has\n * @param {number|string|BigNumber} opts.outcomeTokenIndex - The index of the outcome\n * @param {number|string|BigNumber} opts.outcomeTokenCount - The number of outcome tokens to buy\n * @param {number|string|BigNumber} opts.feeFactor - The fee factor. Specifying 1,000,000 corresponds to 100%, 50,000 corresponds to 5%, etc.\n * @returns {Decimal} The cost of the outcome tokens in event collateral tokens\n * @alias Gnosis.calcLMSRCost\n */\nexport function calcLMSRCost () {\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex, outcomeTokenCount, feeFactor]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSRCost',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256' },\n                { name: 'outcomeTokenIndex', type: 'uint8' },\n                { name: 'outcomeTokenCount', type: 'uint256' },\n                { name: 'feeFactor', type: 'uint24' },\n            ],\n            defaults: {\n                feeFactor: 0,\n            },\n        })\n\n    outcomeTokenCount = new Decimal(outcomeTokenCount.toString())\n\n    let baseCost\n\n    if(funding == 0) {\n        baseCost = outcomeTokenCount\n    } else {\n        const b = new Decimal(funding.toString()).dividedBy(new Decimal(netOutcomeTokensSold.length).ln())\n        baseCost = b.times(\n        netOutcomeTokensSold.reduce((acc, numShares, i) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .plus(i === outcomeTokenIndex ? outcomeTokenCount : 0)\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        .minus(netOutcomeTokensSold.reduce((acc, numShares) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        ))\n    }\n    return baseCost.times(new Decimal(1).plus(new Decimal(feeFactor).dividedBy(1e6)))\n        .times(1+1e-9).ceil()   // TODO: Standardize this 1e-9 and 1e9 in isClose of tests\n                                //       This is necessary because of rounding errors due to\n                                //       series truncation in solidity implementation.\n}\n\n/**\n * Estimates profit from selling specified number of outcome tokens to LMSR market.Unfunded markets will be handled as a special case, returning no profit.\n * @param {number[]|string[]|BigNumber[]} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold by the market already. Negative amount means more have been sold to the market than sold by the market.\n * @param {number|string|BigNumber} opts.funding - The amount of funding market has\n * @param {number|string|BigNumber} opts.outcomeTokenIndex - The index of the outcome\n * @param {number|string|BigNumber} opts.outcomeTokenCount - The number of outcome tokens to sell\n * @param {number|string|BigNumber} opts.feeFactor - The fee factor. Specifying 1,000,000 corresponds to 100%, 50,000 corresponds to 5%, etc.\n * @returns {Decimal} The profit from selling outcome tokens in event collateral tokens\n * @alias Gnosis.calcLMSRProfit\n */\nexport function calcLMSRProfit () {\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex, outcomeTokenCount, feeFactor]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSRProfit',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256' },\n                { name: 'outcomeTokenIndex', type: 'uint8' },\n                { name: 'outcomeTokenCount', type: 'uint256' },\n                { name: 'feeFactor', type: 'uint24' },\n            ],\n            defaults: {\n                feeFactor: 0,\n            },\n        })\n\n    if(funding == 0) {\n        return new Decimal(0)\n    }\n\n    outcomeTokenCount = new Decimal(outcomeTokenCount.toString())\n    let b = new Decimal(funding.toString()).dividedBy(new Decimal(netOutcomeTokensSold.length).ln())\n\n    return b.times(\n        netOutcomeTokensSold.reduce((acc, numShares) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        .minus(netOutcomeTokensSold.reduce((acc, numShares, i) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .minus(i === outcomeTokenIndex ? outcomeTokenCount : 0)\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)).ln()\n        )).times(new Decimal(1).minus(new Decimal(feeFactor).dividedBy(1e6)))\n        .dividedBy(1+1e-9).floor()  // TODO: Standardize this 1e-9 and 1e9 in isClose of tests\n                                    //       This is necessary because of rounding errors due to\n                                    //       series truncation in solidity implementation.\n}\n\n/**\n * Estimates the number of outcome tokens which can be purchased by specified amount of collateral.\n * @param {Number[]|string[]|BigNumber[]} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold. Negative amount means more have been bought than sold.\n * @param {number|string|BigNumber} opts.funding - The amount of funding market has\n * @param {number|string|BigNumber} opts.outcomeTokenIndex - The index of the outcome\n * @param {number|string|BigNumber} opts.cost - The amount of collateral for buying tokens\n * @returns {Decimal} The number of outcome tokens that can be bought\n * @alias Gnosis.calcLMSROutcomeTokenCount\n */\nexport function calcLMSROutcomeTokenCount () {\n    // decimal.js making this reaaally messy :/\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex, cost, feeFactor]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSROutcomeTokenCount',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256'},\n                { name: 'outcomeTokenIndex', type: 'uint8'},\n                { name: 'cost', type: 'uint256'},\n                { name: 'feeFactor', type: 'uint24' },\n            ],\n            defaults: {\n                feeFactor: 0,\n            },\n        })\n\n    cost = new Decimal(cost.toString())\n    let b = new Decimal(funding.toString()).dividedBy(new Decimal(netOutcomeTokensSold.length).ln())\n\n    return b.times(\n        netOutcomeTokensSold.reduce((acc, numShares) =>\n            acc.plus(\n                new Decimal(numShares.toString())\n                .plus(cost.dividedBy(new Decimal(1).plus(new Decimal(feeFactor).dividedBy(1e6))))\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0))\n        .minus(netOutcomeTokensSold.reduce((acc, numShares, i) =>\n            i === outcomeTokenIndex ? acc\n            : acc.plus(\n                new Decimal(numShares.toString())\n                .dividedBy(b)\n                .exp()),\n            new Decimal(0)))\n        .ln()).minus(netOutcomeTokensSold[outcomeTokenIndex]).floor()\n}\n\n/**\n * Estimates the marginal price of outcome token. Unfunded markets with no outcome tokens sold will be handled as a special case, returning (1 / number of outcomes sold).\n * @param {Number[]|string[]|BigNumber[]} opts.netOutcomeTokensSold - Amounts of net outcome tokens that have been sold. Negative amount means more have been bought than sold.\n * @param {number|string|BigNumber} opts.funding - The amount of funding market has\n * @param {number|string|BigNumber} opts.outcomeTokenIndex - The index of the outcome\n * @returns {Decimal} The marginal price of outcome tokens. Will differ from actual price, which varies with quantity being moved.\n * @alias Gnosis.calcLMSRMarginalPrice\n */\nexport function calcLMSRMarginalPrice() {\n    let [[netOutcomeTokensSold, funding, outcomeTokenIndex]] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'calcLMSRMarginalPrice',\n            functionInputs: [\n                { name: 'netOutcomeTokensSold', type: 'int256[]' },\n                { name: 'funding', type: 'uint256'},\n                { name: 'outcomeTokenIndex', type: 'uint8'},\n            ]\n        })\n\n    if(funding == 0 && netOutcomeTokensSold.every(quantity => quantity == 0)) {\n        return new Decimal(1).div(netOutcomeTokensSold.length)\n    }\n\n    const b = Decimal(funding.valueOf()).div(Decimal.ln(netOutcomeTokensSold.length))\n    const expOffset = Decimal.max(...netOutcomeTokensSold).div(b)\n\n    return Decimal(netOutcomeTokensSold[outcomeTokenIndex].valueOf()).div(b).sub(expOffset).exp().div(\n        netOutcomeTokensSold.reduce(\n            (acc, tokensSold) => acc.add(Decimal(tokensSold.valueOf()).div(b).sub(expOffset).exp()),\n            Decimal(0)\n        )\n    )\n}\n"]}