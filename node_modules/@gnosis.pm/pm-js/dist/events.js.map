{"version":3,"sources":["../src/events.js"],"names":["description","ipfs","addJSONAsync","resultHash","log","publishEventDescription","ipfsHash","catJSONAsync","loadEventDescription","methodName","functionInputs","name","type","eventAddress","outcome","opts","contracts","Event","at","event","CentralizedOracle","oracle","requireEventFromTXResult","setOutcome","resolveEvent","createCategoricalEvent","self","callerContract","EventFactory","eventName","eventArgName","resultContract","CategoricalEvent","createScalarEvent","ScalarEvent","estimateGas","using","gasStats","averageGasUsed","Error"],"mappings":"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","file":"events.js","sourcesContent":["import _ from 'lodash'\nimport { wrapWeb3Function, normalizeWeb3Args, requireEventFromTXResult } from './utils'\n\n/**\n * Creates a categorical event.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @function\n * @param {Contract|string} opts.collateralToken - The collateral token contract or its address\n * @param {Contract|string} opts.oracle - The oracle responsible for resolving this event\n * @param {number|string|BigNumber} opts.outcomeCount - The number of outcomes of this event\n * @returns {Contract} The created categorical event\n * @alias Gnosis#createCategoricalEvent\n */\nexport const createCategoricalEvent = wrapWeb3Function((self) => ({\n    callerContract: self.contracts.EventFactory,\n    methodName: 'createCategoricalEvent',\n    eventName: 'CategoricalEventCreation',\n    eventArgName: 'categoricalEvent',\n    resultContract: self.contracts.CategoricalEvent\n}))\n\n/**\n * Creates a scalar event.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @function\n * @param {Contract|string} opts.collateralToken - The collateral token contract or its address\n * @param {Contract|string} opts.oracle - The oracle responsible for resolving this event\n * @param {number|string|BigNumber} opts.lowerBound - The lower bound for the event outcome\n * @param {number|string|BigNumber} opts.upperBound - The upper bound for the event outcome\n * @returns {Contract} The created scalar event\n * @alias Gnosis#createScalarEvent\n */\nexport const createScalarEvent = wrapWeb3Function((self) => ({\n    callerContract: self.contracts.EventFactory,\n    methodName: 'createScalarEvent',\n    eventName: 'ScalarEventCreation',\n    eventArgName: 'scalarEvent',\n    resultContract: self.contracts.ScalarEvent\n}))\n\n/**\n * Publishes an event description onto IPFS.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {Object} eventDescription - A POD object describing the event\n * @param {string} eventDescription.title - A string describing the title of the event\n * @param {string} eventDescription.description - A string describing the purpose of the event\n * @param {string} eventDescription.resolutionDate - A string containing the resolution date of the event\n * @param {string[]} eventDescription.outcomes - A string array containing the outcomes of the event\n * @returns {string} The IPFS hash locating the published event\n * @alias Gnosis#publishEventDescription\n */\nexport async function publishEventDescription (description) {\n    const resultHash = await this.ipfs.addJSONAsync(description)\n    this.log(`published event description on IPFS at ${resultHash}`)\n    return resultHash\n}\n\n/**\n * Loads an event description from IPFS.\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {string} ipfsHash - The IPFS hash locating the published event\n * @returns {Object} A POD object describing the event\n * @alias Gnosis#loadEventDescription\n */\nexport async function loadEventDescription (ipfsHash) {\n    return await this.ipfs.catJSONAsync(ipfsHash)\n}\n\n/**\n * Resolves an event. Assumes event is backed solely by a centralized oracle controlled by you\n *\n * Note: this method is asynchronous and will return a Promise\n *\n * @param {Contract|string} opts.event - The event address or instance\n * @param {number|string|BigNumber} opts.outcome - The outcome to set this event to. This is the zero-based index of the outcome for categorical events and the decimals-adjusted value of the outcome for scalar events.\n * @alias Gnosis#resolveEvent\n */\nexport async function resolveEvent() {\n    const [[eventAddress, outcome], opts] =\n        normalizeWeb3Args(Array.from(arguments), {\n            methodName: 'resolveEvent',\n            functionInputs: [\n                { name: 'event', type: 'address' },\n                { name: 'outcome', type: 'int256'},\n            ]\n        })\n\n    const event = await this.contracts.Event.at(eventAddress)\n    const oracle = await this.contracts.CentralizedOracle.at(await event.oracle(opts))\n    requireEventFromTXResult(await oracle.setOutcome(outcome, opts), 'OutcomeAssignment')\n    requireEventFromTXResult(await event.setOutcome(opts), 'OutcomeAssignment')\n}\n\nresolveEvent.estimateGas = async function({ using }) {\n    if(using === 'stats') {\n        return this.contracts.CentralizedOracle.gasStats.setOutcome.averageGasUsed +\n            this.contracts.Event.gasStats.setOutcome.averageGasUsed\n    }\n    throw new Error(`unsupported gas estimation source ${using}`)\n}\n"]}